{
  
    
        "post0": {
            "title": "회귀분석 6장",
            "content": "6.2 . 다음 자료는 A 제품을 생산하는 공장의 총자산(x)과 총수입(y)과의 관계를 조사한 표이다. . x 25 6 8 5 1 24 17 2 13 14 . y | 10.1 | 2.9 | 3.0 | 1.8 | 0.1 | 9.4 | 6.9 | 0.3 | 5.1 | 6.0 | . 1) &#49328;&#51216;&#46020;&#47484; &#44536;&#47532;&#44256;, &#51201;&#54633;&#54620; &#47784;&#54805;&#51012; &#49444;&#51221;&#54616;&#50668;&#46972;. . x &lt;- c(25,6,8,5,1,24,17,2,13,14) y &lt;- c(10.1,2.9,3.0,1.8,0.1,9.4,6.9,0.3,5.1,6.0) plot(x,y) lm62&lt;-lm(y~x) abline(lm62,col=&#39;red&#39;) . 적합한 모형은 1차선형회귀모형이다. . 2) &#50896;&#51216;&#51012; &#51648;&#45208;&#45716; &#54924;&#44480;&#47784;&#54805; $y= beta_1x + epsilon$ &#51012; &#51201;&#54633;&#49884;&#53412;&#44256; &#48516;&#49328;&#48516;&#49437;&#54364;&#47484; &#51089;&#49457;&#54616;&#50668; &#44480;&#47924;&#44032;&#49444; $H_0 : beta_1 = 0 $ &#51012; &#44160;&#51221;&#54616;&#50668;&#46972;. $ alpha = 0.05 $ . sum(x*y)/sum(x^2) #기울기 구하기 . 0.401410579345088 b1(기울기) 값은 0.401410579345088 이다. . y-0.401410579345088*x #잔차구하기 . &lt;ol class=list-inline&gt;0.0647355163727994 | 0.491536523929472 | -0.211284634760704 | -0.20705289672544 | -0.301410579345088 | -0.233853904282112 | 0.0760201511335046 | -0.502821158690176 | -0.118337531486144 | 0.380251889168768 | &lt;/ol&gt; sum(y-0.401410579345088*x) #잔차의 합이 0이 아니다. . -0.56221662468512 3) &#45800;&#49692;&#54924;&#44480;&#47784;&#54805; $y= beta_0 + beta_1x+ epsilon$&#51012; &#51201;&#54633;&#49884;&#53412;&#44256; &#44208;&#51221;&#44228;&#49688; $R^2$ &#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. . . 6.5 . 다음 표는 남녀 어린이 각각 16명에게 비타민B를 복용시켰을 때 4주간의 성장률에 관한 자료이다. . 남 여 . 성장률(y) | 복용량(x) | 성장률(y) | 복용량(x) | . 17.1 | 0.301 | 18.5 | 0.301 | . 14.3 | 0.301 | 22.1 | 0.301 | . 21.6 | 0.301 | 15.3 | 0.301 | . 24.5 | 0.602 | 23.6 | 0.602 | . 20.6 | 0.602 | 26.9 | 0.602 | . 23.8 | 0.602 | 20.2 | 0.602 | . 27.7 | 0.903 | 24.3 | 0.903 | . 31.0 | 0.903 | 27.1 | 0.903 | . 29.4 | 0.903 | 30.1 | 0.903 | . 30.1 | 1.204 | 28.1 | 0.903 | . 28.6 | 1.204 | 30.3 | 1.204 | . 34.2 | 1.204 | 33.0 | 1.204 | . 37.3 | 1.204 | 35.8 | 1.204 | . 33.3 | 1.505 | 32.6 | 1.505 | . 31.8 | 1.505 | 36.1 | 1.505 | . 40.2 | 1.505 | 30.5 | 1.505 | . 1) &#51452;&#50612;&#51652; &#51088;&#47308;&#50640; $y= beta_0 + beta_1x + epsilon$ &#51060; &#49457;&#47549;&#54620;&#45796;&#44256; &#44032;&#51221;&#54616;&#44256; &#45224;&#45376; &#50612;&#47536;&#51060; &#44033;&#44033;&#51032; &#44221;&#50864;&#50640; &#54924;&#44480;&#49440;&#51012; &#52628;&#51221;&#54616;&#50668;&#46972;. . 2) &#46160; &#44060;&#51032; &#52628;&#51221;&#46108; &#54924;&#44480;&#49440;&#51012; &#44057;&#51008; &#54217;&#47732;&#49345;&#50640; &#45208;&#53440;&#45236;&#50612; &#48708;&#44368;&#54644; &#48372;&#46972;. . 3) &#46160; &#54924;&#44480;&#51649;&#49440;&#51032; &#44592;&#50872;&#44592;&#44032; &#44057;&#51008;&#51648; &#44160;&#51221;&#54616;&#50668;&#46972;. $ alpha = 0.05 $ . 4) &#46160; &#54924;&#44480;&#51649;&#49440;&#51032; &#46041;&#51068;&#49457; &#50668;&#48512;&#47484; &#44160;&#51221;&#54616;&#50668;&#46972;. $ alpha = 0.05 $ . . 6.7 . 단순 회귀 모형에서 회귀제곱합 . $SSR = y&#39;[X(X&#39;X)^{-1} - frac{J}{n}]y = sum_{}^{} ( hat{y_i}- bar{y})^2$ . 의 기댓값을 [정리 6.4]를 이용하여 구하고 잔차제곱합 . $ SSE = sum_{i=1}^{n} (y_i - hat{y_1})^2 $ = $ y&#39;[I-X(X&#39;X)^{-1} X&#39;] y $ . 의 기댓값도 구하여 보아라 . - [정리 6.4] : 만약 벡터 $y sim N( mu,V)$ 이면 ($V$는 분산공분산행렬) . 1) $E(y&#39;Ay) = tr(AV) + mu&#39;A mu $ (이것은 y가 정규분포가 아닐 때도 성립) . 2) $Cov(y,y&#39;Ay) = 2VA mu$ . . 6.10 . 단순회귀모형 . $ y = beta_0 + beta_1 x + epsilon $ , $ epsilon sim N(0, sigma^2)$ . 에서 $H_0 : beta_1 = 0$ 이 성립하면 검정통계량 . $F_0 = frac{MSR}{MSE}$ . 은 비중심모수 $ lambda = 0$ 인 중심 $F(1,n-2)$ 분포가 됨을 보여라([정리 6.8]이용) . - [정리 6.8] . $y sim N( mu,I)$ 이면 $ y&#39;Ay sim $ $ chi^2 {&#39;} $ $ (k, frac{1}{2} mu&#39;A mu)$ 이 되기 위한 필요충분조건은 $A$가 계수 $k$인 멱등행렬이다. .",
            "url": "https://cjfal.github.io/dj/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D6%EC%9E%A5.html",
            "relUrl": "/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D6%EC%9E%A5.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "회귀분석 5장",
            "content": "5.2 . - 어떤 화학반응에서 촉매의 양(x)이 합성물의 소득량(y)에 어떻게 영향을 끼치는지 알아보기 위해 12번 실험하여 다음의 자료를 얻었다. . x(g) 1 1 1 2 2 2 4 4 4 8 8 8 . y(g) | 13.5 | 15.4 | 16.1 | 18.2 | 19.6 | 20.2 | 21.8 | 22.2 | 23.1 | 23.6 | 24.7 | 24.9 | . x &lt;- c(1,1,1,2,2,2,4,4,4,8,8,8) y &lt;- c(13.5,15.4,16.1,18.2,19.6,20.2,21.8,22.2,23.1,23.6,24.7,24.9) . 1) x&#50640;&#45824;&#54620; y&#51032; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . plot(x,y,col=&quot;red&quot;) . 2) $ log_{10} x$&#47484; &#44228;&#49328;&#54616;&#44256; $ log_{10} x$&#50640; &#45824;&#54620; y&#44050;&#51032; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . logx &lt;- log(x,base=10) logx . &lt;ol class=list-inline&gt;0 | 0 | 0 | 0.301029995663981 | 0.301029995663981 | 0.301029995663981 | 0.602059991327962 | 0.602059991327962 | 0.602059991327962 | 0.903089986991944 | 0.903089986991944 | 0.903089986991944 | &lt;/ol&gt; plot(logx,y,col=&quot;blue&quot;) . par(mfrow=c(1,2)) plot(x,y,col=&quot;red&quot;) plot(logx,y,col=&quot;blue&quot;,xlim=c(0,8)) # xlim 으로 x범위 조정 . 3) &#50948; 1)&#44284; 2) &#51473; &#50612;&#45712; &#44163;&#51060; &#45908; &#49440;&#54805;&#50640; &#44032;&#44620;&#50868;&#44032;? . 2)의 로그 그래프가 같은 범위에서 더 선형에 가깝다. . . 5.3 . - 연습문제 5.2의 자료에 대해 다음 질문에 답하여라. . 1) $ y = beta_0 + beta_1 x + epsilon $ &#47484; &#51201;&#54633;&#49884;&#53412;&#44256; $MSE$ &#47484; &#44396;&#54616;&#50668;&#46972;. . lm53 &lt;- lm(y~x) coefficients(lm53) . &lt;dl class=dl-inline&gt;(Intercept)15.8130434782609x1.18985507246377&lt;/dl&gt; $y= 15.51 + 1.19x$ . anova(lm53) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . x 1 | 122.10888 | 122.108877 | 34.1147 | 0.0001636405 | . Residuals10 | 35.79362 | 3.579362 | NA | NA | . $MSE$ :Mean Square Residuals = 3.579362 . 2) $ y = beta_0 + beta_1 log_{10} x + epsilon $ &#47484; &#44032;&#51221;&#54616;&#44256; $MSE$ &#47484; &#44228;&#49328;&#54616;&#50668;&#46972;. . lm53log &lt;- lm(y~logx) anova(lm53log) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . logx 1 | 146.32817 | 146.328167 | 126.4247 | 5.374543e-07 | . Residuals10 | 11.57433 | 1.157433 | NA | NA | . $MSE$ :Mean Square Residuals = 1.157433 . 3) &#50948; 1)&#44284; 2)&#51032; &#47784;&#54805; &#51473; &#50612;&#45712; &#44163;&#51060; &#45908; &#51201;&#54633;&#54620;&#51648; $MSE$ &#47484; &#51060;&#50857;&#54616;&#50668; &#48708;&#44368;&#54616;&#50668;&#46972;. . $ log_{10} x$ 에서의 $MSE$ 가 더 작다. 즉, 2)의 모형이 더 적합하다. . . 5.12 . - 다음 과 같은 자료에 대하여 . x 2 6 10 . y | 4 | 7 | 4 | . 1) &#45800;&#49692;&#54924;&#44480;&#47784;&#54805; $ y = beta_0 + beta_1 x + epsilon $ , $ epsilon sim N(0, sigma^2)$&#51012; &#44032;&#51221;&#54616;&#44256; &#54924;&#44480;&#51649;&#49440;&#51012; &#52628;&#51221;&#54616;&#50668;&#46972;. &#46608; $ beta_1$ &#51032; 90% &#49888;&#47280;&#44396;&#44036;&#51012; &#44396;&#54616;&#50668;&#46972;. . x &lt;- c(2, 6, 10) y &lt;- c(4, 7, 4) lm512 &lt;- lm(y~x) coefficients(lm512) confint(lm512,level = 0.90) # 기울기와 절편의 90% 신뢰구간 . &lt;dl class=dl-inline&gt;(Intercept)5x-4.81432375190295e-16&lt;/dl&gt; A matrix: 2 × 2 of type dbl 5 %95 % . (Intercept)-13.676329 | 23.676329 | . x -2.733935 | 2.733935 | . 기울기 $ beta_1$의 90% 신뢰구간:$(-2.733935, 2.733935)$ . 2) $ y = beta_0 + beta_1 x + epsilon $ , $ epsilon sim N(0,k^2 {x_i}^2)$ &#51012; &#44032;&#51221;&#54616;&#50668; &#44032;&#51473;&#54924;&#44480;&#51649;&#49440;&#51012; &#52628;&#51221;&#54616;&#44256; $ beta_1$ &#51032; 90% &#49888;&#47280;&#44396;&#44036;&#51012; &#44396;&#54616;&#50668;&#46972;. . w512 &lt;- sqrt(1/var(x)) . 3) &#50948; 1), 2)&#51032; &#44208;&#44284;&#47484; &#48708;&#44368;&#54616;&#50668;&#46972; . . 5.14 . - 다음은 어떤 컴퓨터 부품의 과거 14개월(x) 동안의 판매액(y)에 관한 자료이다. . x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . y | 6.0 | 6.3 | 6.1 | 6.8 | 7.5 | 8.0 | 8.1 | 8.5 | 9.0 | 8.7 | 7.9 | 8.2 | 8.4 | 9.0 | . 1) &#45936;&#51060;&#53552;&#51032; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . x &lt;- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14) y &lt;- c(6.0,6.3,6.1,6.8,7.5,8.0,8.1,8.5,9.0,8.7,7.9,8.2,8.4,9.0) plot(x,y) . 2) &#45800;&#49692;&#54924;&#44480;&#47784;&#54805;&#51012; &#44032;&#51221;&#54616;&#44256; &#51092;&#52264;&#51032; &#49328;&#51216;&#46020;&#47484; &#45208;&#53440;&#45236;&#44256; &#51088;&#44592;&#49345;&#44288;&#51060; &#51316;&#51116;&#54616;&#45716;&#51648;&#47484; &#44160;&#53664;&#54616;&#50668;&#46972;. . lm514 &lt;- lm(y~x) coefficients(lm514) . &lt;dl class=dl-inline&gt;(Intercept)6.13296703296704x0.215604395604395&lt;/dl&gt; err &lt;- function(A){ print(0.215604395604395 * A + 6.13296703296704) } . plot(err(x)-y) . [1] 6.348571 6.564176 6.779780 6.995385 7.210989 7.426593 7.642198 7.857802 [9] 8.073407 8.289011 8.504615 8.720220 8.935824 9.151429 . 3) Durbin-Watson d &#53685;&#44228;&#47049;&#51032; &#44050;&#51012; &#44396;&#54616;&#50668; $H_0 : rho = 0 , H_1 : rho neq 0 $ &#51012; $ alpha = 0.05 $ &#47196; &#44160;&#51221;&#54616;&#50668;&#46972;. . 4) &#50948; 3)&#51032; &#44160;&#51221;&#44208;&#44284;&#45716; 2)&#51032; &#49328;&#51216;&#46020;&#50640;&#49436; &#50619;&#51008; &#45712;&#45196;&#44284; &#51068;&#52824;&#54616;&#45716;&#51648; &#45436;&#51032;&#54616;&#50668;&#46972;. .",
            "url": "https://cjfal.github.io/dj/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D5%EC%9E%A5.html",
            "relUrl": "/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D5%EC%9E%A5.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "회귀분석3장연습문제2",
            "content": "# 회귀분석 3장 연습문제 뒷부분 .",
            "url": "https://cjfal.github.io/dj/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D3%EC%9E%A5%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C2.html",
            "relUrl": "/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D3%EC%9E%A5%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C2.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "회귀분석 3장 연습문제1",
            "content": "3.3) &#50612;&#45712; &#51613;&#44428;&#54924;&#49324;&#50640;&#49436;&#51032; &#51452;&#44032;x&#50752; &#51333;&#54633;&#51452;&#44032;&#51648;&#49688;y &#48516;&#49437; . Base . x &lt;- c(650, 670, 690, 650, 660, 650, 670, 660, 690, 710) y &lt;- c(210, 212, 217, 215, 216, 214, 220, 218, 220, 224) lm33 &lt;- lm(y~x) . 1) &#54364;&#48376;&#49345;&#44288;&#44228;&#49688; &#44396;&#54616;&#44592; . cor(x,y) . 0.757203385853764 2) &#45800;&#49692;&#54924;&#44480;&#49440; &#52628;&#51221;, &#49328;&#51216;&#46020; . plot(y~x) abline(lm(y~x),col=&quot;red&quot;) . 3) MSE &#44228;&#49328; &#48143; &#49328;&#51216;&#46020;&#50752; &#48708;&#44368; . anova(lm33) summary(lm33) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . x1 | 88.52632 | 88.526316 | 10.75104 | 0.01120658 | . Residuals8 | 65.87368 | 8.234211 | NA | NA | . Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -4.6000 -1.9026 0.6895 1.4132 3.4000 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 114.33684 31.20166 3.664 0.00636 ** x 0.15263 0.04655 3.279 0.01121 * Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 2.87 on 8 degrees of freedom Multiple R-squared: 0.5734, Adjusted R-squared: 0.52 F-statistic: 10.75 on 1 and 8 DF, p-value: 0.01121 . 4) &#51092;&#52264;&#47484; &#44396;&#54616;&#44256; &#54633;&#51060; 0&#51060; &#46104;&#45716; &#44163;&#51012; &#54869;&#51064; . lm33$residuals . &lt;dl class=dl-inline&gt;1-3.54736842105262-4.63-2.6526315789473741.4526315789473650.92631578947367760.45263157894735973.482.9263157894736890.347368421052632101.29473684210527&lt;/dl&gt; -3.5473684-4.6000000-2.6526316+1.4526316+0.9263158+0.4526316+3.4000000+2.9263158+0.3473684+1.2947368 . 8.88178419700125e-16 sum(lm33$residuals) . 1.55431223447522e-15 $ to$ 둘다 0에 수렴하는 값 . 5) &#51092;&#52264;&#46308;&#51032; x&#50640; &#51032;&#54620; &#44032;&#51473;&#54633;&#51060; 0&#51060; &#46120;&#51012; &#48372;&#51060;&#44592; . res33 &lt;- lm33$residuals x*res33 . &lt;dl class=dl-inline&gt;1-2305.789473684192-30823-1830.315789473684944.2105263157835611.3684210526276294.2105263157847227881931.368421052639239.68421052631610919.26315789474&lt;/dl&gt; -2305.7895 -3082.0000 -1830.3158+944.2105+611.3684+294.2105+2278.0000+ 1931.3684 +239.6842 + 919.2632 . -9.99999995201506e-05 sum(x*res33) . -4.54747350886464e-13 $ to$ 둘다 0에 수렴하는 값 . 6) &#51092;&#52264;&#46308;&#51032; yhat&#50640; &#51032;&#54620; &#44032;&#51473;&#54633;&#51060; 0&#51060; &#46120;&#51012; &#48372;&#51060;&#44592; . res33*0.15263+(res33*(114.33684*x)) . &lt;dl class=dl-inline&gt;1-263637.2235611552-352386.8429783-209272.9284416844107958.269588841569902.0747225258633639.17095884147260459.8404628220827.008782526927404.788248315810105105.84221779&lt;/dl&gt; -263637.22 -352386.84 -209272.93 + 107958.27 + 69902.07 + 33639.17 +260459.84 + 220827.01 + 27404.79+ 105105.84 . 1.16415321826935e-10 sum(res33*0.15263+(res33*(114.33684*x)) ) . 4.36557456851006e-11 $ to$ 둘다 0에 수렴하는 값 . . 3.5) &#50612;&#46500; &#52980;&#54504;&#53552;&#54924;&#49324;&#51032; &#49436;&#48708;&#49828; &#50836;&#44396;&#44148;&#49688;&#50752; &#49688;&#47532;&#49884;&#44036; &#48516;&#49437; . Base . library(ggplot2) x &lt;- c(4,2,5,7,1,3,4,5,2,4,6) y &lt;- c(109,58,138,189,37,82,103,134,68,112,154) lm35 &lt;- lm(y~x) . 1) &#49328;&#51216;&#46020; &#44536;&#47532;&#44592; . plot(y~x) abline(lm35,col=&quot;red&quot;) . 2) 1&#52264;&#49440;&#54805;&#54924;&#44480;&#49440;&#51012; &#44032;&#51221;&#54616;&#44256; &#52572;&#49548;&#51228;&#44273;&#52628;&#51221;&#47049; b0&#50752; b1&#44396;&#54616;&#44592; . coef(lm35) # b0(절편,intercept), b1(기울기,x) . &lt;dl class=dl-inline&gt;(Intercept)11.46408839779x24.6022099447514&lt;/dl&gt; xbar &lt;- mean(x) ybar &lt;- mean(y) minusx &lt;- x-xbar minusy &lt;- y-ybar . Sxx &lt;- sum(minusx^2) Sxx . 32.9090909090909 Syy &lt;- sum(minusy^2) Syy . 20110.5454545455 Sxy &lt;- sum(minusx*minusy) Sxy . 809.636363636364 b1 &lt;- Sxy/Sxx b1 . 24.6022099447514 b0 &lt;- ybar - b1*xbar b0 . 11.4640883977901 3) &#52628;&#51221;&#52824; b1&#51032; &#51032;&#48120;&#47484; &#49444;&#47749;&#54616;&#50668;&#46972; . 기울기 . 4) &#49436;&#48708;&#49828; &#49688;&#44032; 4&#51068; &#46412; &#49688;&#47532;&#49884;&#44036; &#52628;&#51221;, &#52628;&#51221;&#44050;&#51032; &#51032;&#48120; . 적합된 회귀선으로 추정한 x=4 일때의 y의 예측(추정) 값 . yhat=b0+b1x . b0+b1*4 . 109.872928176796 5) &#49328;&#51221;&#46020; &#50948;&#50640; &#52628;&#51221;&#46108; &#54924;&#44480;&#51649;&#49440; &#46020;&#49884;&#54616;&#44256; &#51092;&#52264;&#54364;&#49884; . library(ggplot2) library(modelr) . df &lt;- data.frame(x,y) df . A data.frame: 11 × 2 xy . &lt;dbl&gt;&lt;dbl&gt; . 4 | 109 | . 2 | 58 | . 5 | 138 | . 7 | 189 | . 1 | 37 | . 3 | 82 | . 4 | 103 | . 5 | 134 | . 2 | 68 | . 4 | 112 | . 6 | 154 | . 103-109.86 . -6.86 ggplot(df, aes(x=x, y=y)) + geom_point() + stat_smooth(method=&#39;lm&#39;) + geom_text(x=1,y=37,label=&quot;0.94&quot;)+ geom_text(x=2,y=58,label=&quot;-2.66&quot;)+ geom_text(x=2,y=68,label=&quot;7.34&quot;)+ geom_text(x=3,y=82,label=&quot;-3.26&quot;)+ geom_text(x=4,y=103,label=&quot;-6.86&quot;)+ geom_text(x=4,y=109,label=&quot;-0.86&quot;)+ geom_text(x=4,y=112,label=&quot;2.14&quot;)+ geom_text(x=5,y=134,label=&quot;-0.46&quot;)+ geom_text(x=5,y=138,label=&quot;3.54&quot;)+ geom_text(x=6,y=154,label=&quot;-5.06&quot;)+ geom_text(x=7,y=189,label=&quot;5.34&quot;) . `geom_smooth()` using formula &#39;y ~ x&#39; . 6) &#49345;&#44288;&#44228;&#49688; &#44396;&#54616;&#44592; . cor(x,y) . 0.995222389856898 . 3.9) &#50612;&#45712; &#54617;&#44553;&#51032; &#49884;&#54744;&#51216;&#49688;y&#50752; &#44208;&#49437;&#51068;&#49688;x &#49324;&#51060;&#51032; &#44288;&#44228; . n=50 . $ sum_{}^{} x_i$ = 18 . $ sum_{}^{} y_i$ = 3000 . $ sum_{}^{} xy$ = 8800 . $ sum_{}^{} x^2$ = 680 . $ sum_{}^{} y_i^2$ = 196000 . 1) &#49884;&#54744;&#51216;&#49688;&#50752; &#44208;&#49437;&#51068;&#49688; &#49324;&#51060;&#51032; &#54364;&#48376;&#49345;&#44288;&#44228;&#49688;&#47484; &#44396;&#54616;&#50668;&#46972; . 표본상관계수 :$r_xy = frac{S_(xy)}{S_x S_y} = 157.551/(3.7075 * 18.07)=2.3517 $ . $S_xy = frac{1}{n-1} { sum_{}^{} xy - frac{ sum_{}^{} x sum_{}^{} y}{n} } =157.551$ . $S_x = sqrt{ frac{1}{n-1} { sum_{}^{} x^2 - frac{ sum_{}^{} x^2}{n} }} = 3.7075$ . $S_y = sqrt{ frac{1}{n-1} { sum_{}^{} y^2 - frac{ sum_{}^{} y^2}{n} }} = 18.07$ . 2) &#45824;&#52404;&#47784;&#54805; &#54924;&#44480;&#49440;&#50640;&#49436; beta_0 &#44284; beta_1 &#51032; &#52572;&#49548;&#51228;&#44273;&#52628;&#51221;&#47049;&#51012; &#44396;&#54644;&#46972; . 정규방정식 . $b_0n + b_1 sum_{}^{} x_i = sum_{}^{} y_i$ . $b_0 sum_{}^{} x_i + b_1 sum_{}^{} x_i^2 = sum_{}^{} x_i y_i$ . 50$b_0$+18$b_1$=3000 . 18$b_0$+680$b_1$=8800 이고, 연립방정식을 풀면 . $b_0$ = 55.87 , $b_1$ = 11.46 이다. . 3) &#44208;&#49437;&#51012; 3&#48264;&#54620; &#54617;&#49373;&#50640; &#45824;&#54620; &#54217;&#44512;&#49457;&#51201;&#51032; &#52628;&#51221;&#47049;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. . $ hat{y} = b_0 + b_1x to hat{y} = 55.87 + 11.46 * 3 = 90.25$ . 4) &#50724;&#52264;&#54637; $ epsilon$ &#51032; &#54364;&#51456;&#54200;&#52264; $ sigma$ &#47484; &#44396;&#54616;&#50668;&#46972; . $SSE= sum_{}^{} y_i^2 - b_0 sum_{}^{} y_i - b_1 sum_{}^{} xy =196000-55.87×3000-11.46×8800 = -72458$ . $ sigma = MSE = frac{SSE}{n-2} = -1510$ .",
            "url": "https://cjfal.github.io/dj/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D3%EC%9E%A5%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C1.html",
            "relUrl": "/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/10/12/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D3%EC%9E%A5%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C1.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "데이터시각화 10/6 강의 정리",
            "content": "import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns from scipy import stats . qqplot . - 히스토그램이나 박스플랏보다 분포를 특정하기에 좋은 시각화는 없을까? . 정규분포 크기 1000 평균 2 표준편차 1.5 . t분포 자유도 10 크기 1000 표준편차 루트(자유도/(자유도-2)) . t분포는 평균이 0 | . np.random.seed(43052) x=np.random.normal(size=1000,loc=2,scale=1.5) y=stats.t.rvs(df=10,size=1000)/np.sqrt(10/8)*1.5 + 2 . plt.hist(y) . (array([ 1., 2., 5., 47., 164., 342., 311., 95., 26., 7.]), array([-5.32281821, -4.04507802, -2.76733783, -1.48959763, -0.21185744, 1.06588276, 2.34362295, 3.62136314, 4.89910334, 6.17684353, 7.45458373]), &lt;BarContainer object of 10 artists&gt;) . 가끔식 튀는 큰값이 나온다 . - 우리가 관측한 $x_1, dots,x_{1000}$이 $N(2,1.5^2)$에서 나온 샘플인지 궁금하다. . (1) 관측한 값을 순서대로 나열하여 $x_{(1)},x_{(2)}, dots, x_{(1000)}$을 만든다. . x[:2] #2번째 까지만 보이기 . array([2.57513073, 3.62626175]) . $x_1=2.57513073, quad x_2=3.62626175$ | . x.sort() # 작은 순 정렬 . x[:2] . array([-2.44398446, -2.14071467]) . $x_{(1)}= -2.44398446, quad x_{(2)}=-2.14071467$ | . (2) 파이썬이나 R로 $N(2,1.5^2)$에서 1000개의 정규분포를 생성. 그리고 순서대로 나열하여 $ tilde{x}_{(1)}, tilde{x}_{(2)}, dots, tilde{x}_{(1000)}$를 만든다. . (3) $x_{(1)} approx tilde{x}_{(1)}, dots , x_{(1000)} approx tilde{x}_{(1000)}$ 이면 x는 정규분포일것 . 그런데 $ tilde{x}_{(1)}, tilde{x}_{(2)}, dots, tilde{x}_{(1000)}$은 시뮬레이션을 할때마다 다른값이 나올테니까 불안정한 느낌이 든다. $ to$ 이론적인 값을 계산하자. . xx = (x-np.mean(x)) / np.std(x,ddof=1) # x를 표준화 xx[:2] . array([-3.05569305, -2.84275629]) . print(stats.norm.ppf(0.001)) #실제우리가 관측한 값 print(stats.norm.ppf(0.002)) . -3.090232306167813 -2.878161739095483 . m=[i/1000 for i in np.arange(1000)+1] # 이론적인 값 - 분위수 . np.arange(1000)[:10] . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . q=[] for i in range(len(m)): q=q+[stats.norm.ppf(m[i])] . q[:2] . [-3.090232306167813, -2.878161739095483] . $xx approx q$ 을 확인하기 위해서 $(q,q)$그래프와 $(q,xx)$의 그래프를 그려서 겹쳐보자. . plt.plot(q,xx,&#39;o&#39;) #표준화 : 동그라미점 선 plt.plot(q,q,&#39;-&#39;) #이론적인값 : 직선 . [&lt;matplotlib.lines.Line2D at 0x7f00b75caca0&gt;] . 해석: 점들이 주황색선 근처에 모여있을수록 정규분포에 가깝다. 굉장히 좋게 나온 예시 . | . - 아래와 같이 쉽게 그릴수도 있다. (_ = stats.probplot(x,plot=plt)우리가 그린그림과 조금 다르게 보인다) y축이 다름 . 자세히보면 조금 다르게 그려지긴 하는데 이는 $m=( frac{1}{1000}, dots, frac{999}{1000}, frac{1000}{1000})$와 같이 계산하지 않고 약간 보정한값을 계산하기 때문임 . | stats.probplot? 을 통하여 확인한 결과 아래와 같은 코드로 구현됨 . ### 보정하는방법1 n=len(xx) m=[((i+1)-0.3175)/(n+0.365) for i in range(n)] m[-n]=0.5**(1/n) m[0]=1-m[-n] . | 프로그램에 따라서 아래와 같이 보정하는 경우도 있음### 보정하는방법2 m=[(i-3/8)/(n+1/4) for i in np.arange(1000)+1] . | 또 자세히보면 stats.probplot은 y축에 표준화전의 x값이 있음을 알 수 있음. | . _ = stats.probplot(x,plot=plt) . _ = stats.probplot(x,plot=plt) # 정규분포 . _ = stats.probplot(y,plot=plt) # t분포 . t분포: 푸른점들이 대체로 붉은선위에 놓여있는듯 하지만 양끝단에서는 그렇지 않다. (중앙부근은 정규분포와 비슷하지만, 꼬리부분은 정규분포와 확실히 다르다) | 왼쪽꼬리: 이론적으로 나와야 할 값보다 더 작은값이 실제로 관측됨 | 오른쪽꼬리: 이론적으로 나와야 할 값보다 더 큰값이 실제로 관측됨 | 해석: 이 분포는 정규분포보다 두꺼운 꼬리를 가진다. | . &#49436;&#47196; &#45796;&#47480; &#54056;&#53412;&#51648;&#47484; &#49324;&#50857;&#54664;&#45716;&#45936; &#48537;&#50668;&#49436; &#44536;&#47532;&#44256; &#49910;&#51020; . matplot 기반이라 같이 쓸 수 있는 패키지가 있음 . fig , (ax1,ax2) = plt.subplots(1,2) fig.set_figwidth(8) # 그래프 크기 늘리기 . _ = stats.probplot(x,plot=ax1) _ = stats.probplot(y,plot=ax2) ax1.set_title(&#39;normal dist&#39;) ax2.set_title(&#39;t dist&#39;) . Text(0.5, 1.0, &#39;t dist&#39;) . fig . &#50696;&#51228;4 (boxplot, histrogram, qqplot) . - 박스플랏, 히스토그램, qqplot을 같이 그려보자. . fig, ax =plt.subplots(2,3) . (ax1,ax2,ax3), (ax4,ax5,ax6) = ax #각각의 축에 접근 . sns.boxplot(x,ax=ax1) #ax1에 박스플랏을 넣겠다 sns.histplot(x,kde=True,ax=ax2) #ax2에 히스토그램 _ = stats.probplot(x,plot=ax3) #ax3에 qq플랏 sns.boxplot(y,ax=ax4) sns.histplot(y,kde=True,ax=ax5) _ = stats.probplot(y,plot=ax6) #넒게 조정 fig.set_figwidth(10) fig.set_figheight(8) fig.tight_layout() . /home/kdj/anaconda3/lib/python3.8/site-packages/seaborn/_decorators.py:36: FutureWarning: Pass the following variable as a keyword arg: x. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. warnings.warn( /home/kdj/anaconda3/lib/python3.8/site-packages/seaborn/_decorators.py:36: FutureWarning: Pass the following variable as a keyword arg: x. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. warnings.warn( . fig . 지금까지는 가운데를 타겟으로 봤는데, 아래쪽그래프들은 양극단 데이터도 무시할 수가 없다. -&gt; ex)아마존 : 정규분포의 가운데가 마냥 맞는 것은 아니다. 전략 수립에서 정규성을 벗어나는지 봐야한다. . &#48516;&#50948;&#49688;&#47484; &#44396;&#54616;&#45716; &#45796;&#50577;&#54620; &#48169;&#48277; . m=[i/1000 for i in np.arange(1000)+1] #리스트 컴프리헨션 # np.arange(1000) : 0~999 . $m= big { frac{i}{1000}: i in {1,2,3, dots,1000 } big }= big { frac{1}{1000}, frac{2}{1000}, dots, frac{1000}{1000} big }$ | . m[:5] . [0.001, 0.002, 0.003, 0.004, 0.005] . range? . Init signature: range(self, /, *args, **kwargs) Docstring: range(stop) -&gt; range object range(start, stop[, step]) -&gt; range object Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. These are exactly the valid indices for a list of 4 elements. When step is given, it specifies the increment (or decrement). Type: type Subclasses: . range . 처음부터 정수 시퀀스를 생성하는 개체 반환(포함) 단계별로 정지(정지)합니다. . 범위(i, j)는 i, i+1, i+2, ..., j-1을 생성합니다. . start 기본값은 0이고 stop은 생략됩니다! range(4)는 0, 1, 2, 3을 생성합니다. . 이들은 정확히 4개의 원소 목록에 대한 유효한 지수이다. . 단계가 지정되면 증분(또는 감소)을 지정합니다. . stats.norm.ppf? . Signature: stats.norm.ppf(q, *args, **kwds) Docstring: Percent point function (inverse of `cdf`) at q of the given RV. Parameters - q : array_like lower tail probability arg1, arg2, arg3,... : array_like The shape parameter(s) for the distribution (see docstring of the instance object for more information) loc : array_like, optional location parameter (default=0) scale : array_like, optional scale parameter (default=1) Returns - x : array_like quantile corresponding to the lower tail probability q. File: ~/anaconda3/lib/python3.8/site-packages/scipy/stats/_distn_infrastructure.py Type: method . stats.norm.ppf() . 주어진 RV의 q에서 백분율 포인트 함수(&#39;cdf&#39;의 역) . Parameters . q : array_like 낮은 꼬리 확률 arg1, arg2, arg3,... : array_like 분포에 대한 형상 모수(의 문서 문자열 참조) 자세한 내용을 보려면 인스턴스 개체) loc : array_like, 옵션 위치 매개 변수(기본값=0) scale : array_like, 옵션 척도 모수(기본값=1) . return . x : array_like = 아래쪽 꼬리 확률 q에 해당하는 분위수입니다. . q=[] for i in range(len(m)): q=q+[stats.norm.ppf(m[i])] q[:5] . [-3.090232306167813, -2.878161739095483, -2.7477813854449926, -2.6520698079021954, -2.575829303548901] . q=[stats.norm.ppf(m[i]) for i in range(len(m))] q[:5] . [-3.090232306167813, -2.878161739095483, -2.7477813854449926, -2.6520698079021954, -2.575829303548901] . q=list(map(stats.norm.ppf, m)) q[:5] . [-3.090232306167813, -2.878161739095483, -2.7477813854449926, -2.6520698079021954, -2.575829303548901] . stats.norm.ppf(m)[:5] . array([-3.09023231, -2.87816174, -2.74778139, -2.65206981, -2.5758293 ]) . lambda . lambda &#49324;&#50857;&#48277; . f = lambda x,y,z : x+y+z ## lambda 입력:출력 #이자체가 오브젝트로 취급된다. . f(2,3,4) . 9 . lambda &#46356;&#54260;&#53944;&#51077;&#47141;&#44050; . x= (lambda a=&#39;fee&#39;,b=&#39;fie&#39;,c=&#39;foe&#39;: a+b+c) . x(&#39;wee&#39;) . &#39;weefiefoe&#39; . lambda&#51032; &#47532;&#49828;&#53944;&#54868; . l = [lambda x: x**2, lambda x: x**3, lambda x: x**4] #리스트안에 람다 3개 . for f in l: print(f(2)) . 4 8 16 . lambda&#51032; &#46357;&#49492;&#45320;&#47532;&#54868; . dct={&#39;f1&#39;: (lambda x: x+1), &#39;f2&#39;: (lambda x: x+22), &#39;f3&#39;: (lambda x: x+333)} . dct[&#39;f1&#39;](1), dct[&#39;f2&#39;](1), dct[&#39;f3&#39;](1) . (2, 23, 334) . lambda&#51032; &#51312;&#44148;&#48512; &#52636;&#47141; . lower = lambda x,y : x if x&lt;y else y . lower(&#39;a&#39;,&#39;b&#39;) . &#39;a&#39; . lower(&#39;c&#39;,&#39;b&#39;) . &#39;b&#39; . lambda expression &#51012; return &#51077;&#47141;&#44032;&#45733; . def action(x): return (lambda y: x+y) #리턴을 람다로 . act = action(99) ## act를 99+y를 수행하는 함수로 저장 act2 = action(98) ## act2를 98+y를 수행하는 함수로 저장 . action은 마치 함수를 만드는 함수같다.. | . print(act(2)) # act안에 y에 2를 넣겠다. 99+2 print(act2(2)) # act2안에 y에 2를 넣겠다. 98+2 . 101 100 . &#50696;&#51228;6&#51032; &#48156;&#51204; . action = lambda x: (lambda y: x+y) # 람다 출력에 또 람다 . act= action(99) #x에 99를 넣은 함수 act 선언 act2=action(98) #x에 98를 넣은 함수 act2 선언 . print(act(2)) print(act2(2)) . 101 100 . 괄호를 생략하여 선언하면 . action = lambda x: lambda y: x+y act= action(99) act2=action(98) print(act(2)) print(act2(2)) # 똑같다. . 101 100 . map . map? #map(func, *iterables) --&gt; map 개체 #다음 인수를 사용하여 함수를 계산하는 반복자를 만듭니다. #각 반복 사항 최단 시간이 소진되면 중지됩니다. . Init signature: map(self, /, *args, **kwargs) Docstring: map(func, *iterables) --&gt; map object Make an iterator that computes the function using arguments from each of the iterables. Stops when the shortest iterable is exhausted. Type: type Subclasses: . map &#49324;&#50857;&#48169;&#48277; . def inc(x): return x+1 #임시로 쓸건데 공간도 차지하고 좀 그럼 $ to$ 람다로 처리 . list(map(inc,[1,2,3,4])) . [2, 3, 4, 5] . &#50696;&#51228;1&#51032; &#48320;&#54805;(&#46988;&#45796;&#49324;&#50857;) . list(map(lambda x: x+1,[1,2,3,4])) . [2, 3, 4, 5] . list(map(def inc(x): return x+1,[1,2,3,4])) #안됨 . File &#34;&lt;ipython-input-69-e70d258d54b1&gt;&#34;, line 1 list(map(def inc(x): return x+1,[1,2,3,4])) #안됨 ^ SyntaxError: invalid syntax . 함수명을 쓰는 자리에 lambda로 표현한 오브젝트 자체를 전달할 수 있다. $ to$ 코드가 간단하다. | . map&#44284; &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496; &#48708;&#44368; . (함수선언) . f = lambda x: &#39;X&#39; in x . f(&#39;X1&#39;),f(&#39;X2&#39;),f(&#39;Y1&#39;),f(&#39;Y2&#39;) . (True, True, False, False) . (map) . list(map(f,[&#39;X1&#39;,&#39;X2&#39;,&#39;Y3&#39;,&#39;Y4&#39;])) . [True, True, False, False] . (리스트컴프리헨션과 비교) . [f(x) for x in [&#39;X1&#39;,&#39;X2&#39;,&#39;Y3&#39;,&#39;Y4&#39;]] . [True, True, False, False] . &#46160;&#44060;&#51032; &#51077;&#47141;&#51012; &#48155;&#45716; &#54632;&#49688;(pow) map, &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496; &#48708;&#44368; . (함수소개) . pow(2,4) #2를 4제곱 . 16 . (map) . list(map(pow,[2,2,2,3,3,3],[0,1,2,0,1,2])) . [1, 2, 4, 1, 3, 9] . (리스트컴프리헨션과 비교) . [pow(x,y) for x,y in zip([2,2,2,3,3,3],[0,1,2,0,1,2])] #zip이라는 새로운 오브젝트 생성 . [1, 2, 4, 1, 3, 9] . map은 (하나의 함수,다양한 입력)인 경우 사용가능 . l=[lambda x: x+1, lambda x: x+2, lambda x: x+3 ] . list(map(l,[100,200,300])) . TypeError Traceback (most recent call last) &lt;ipython-input-78-dcc049c06067&gt; in &lt;module&gt; -&gt; 1 list(map(l,[100,200,300])) TypeError: &#39;list&#39; object is not callable . 리스트컴프리헨션은 (다양한함수,다양한입력)이 가능함 . [l[i](x) for i,x in zip([0,1,2],[100,200,300])] . [101, 202, 303] . 리스트컴프리헨션은 (다양한함수,다양한입력)이 가능함 . [l[i](x) for i,x in zip([0,1,2],[100,200,300])] . [101, 202, 303] . 종합:map을 리스트컴프리헨션과 비교 . (1) 반복인덱스를 쓰지 않는 장점 . (2) 좀 더 제약적으로 사용할 수 밖에 없다는 단점 . &#51339;&#51008; &#49884;&#44033;&#54868; &#54616;&#44592; . - 왜 우수한 그래프일까? . 자료를 파악하는 기법은 최근까지도 산점도, 막대그래프, 라인플랏에 의존 | 이러한 플랏의 단점은 고차원의 자료를 분석하기 어렵다는 것임 | 미나드는 여러그램을 그리는 방법 대신에 한 그림에서 패널을 늘리는 방법을 선택함. | . &#49884;&#44033;&#54868; &#50696;&#51228; . x=[44,48,49,58,62,68,69,70,76,79] ## 몸무게 y=[159,160,162,165,167,162,165,175,165,172] ## 키 g= &#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;m&#39;,&#39;f&#39;,&#39;m&#39;,&#39;m&#39;,&#39;m&#39;,&#39;m&#39; df=pd.DataFrame({&#39;w&#39;:x,&#39;h&#39;:y,&#39;g&#39;:g}) . df . w h g . 0 44 | 159 | f | . 1 48 | 160 | f | . 2 49 | 162 | f | . 3 58 | 165 | f | . 4 62 | 167 | m | . 5 68 | 162 | f | . 6 69 | 165 | m | . 7 70 | 175 | m | . 8 76 | 165 | m | . 9 79 | 172 | m | . - 미나드의 접근방법 . sns.scatterplot(data=df,x=&#39;w&#39;,y=&#39;h&#39;,hue=&#39;g&#39;) . &lt;AxesSubplot:xlabel=&#39;w&#39;, ylabel=&#39;h&#39;&gt; . - 일반적인 사람들 (보통 색깔을 사용할 생각을 못한다.) . figs = sns.FacetGrid(df,col=&#39;g&#39;) figs.map (sns.scatterplot,&#39;w&#39;,&#39;h&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x7f00b6fa36d0&gt; . - 생각보다 데이터가 정리된 형태에 따라서 시각화에 대한 사고방식이 달라진다. 아래와 같은 자료를 받았다고 하자. . df1=df.query(&quot;g ==&#39;f&#39;&quot;)[[&#39;w&#39;,&#39;h&#39;]] ## 여성.csv df2=df.query(&quot;g ==&#39;m&#39;&quot;)[[&#39;w&#39;,&#39;h&#39;]] ## 남성.csv . df1 . w h . 0 44 | 159 | . 1 48 | 160 | . 2 49 | 162 | . 3 58 | 165 | . 5 68 | 162 | . df2 . w h . 4 62 | 167 | . 6 69 | 165 | . 7 70 | 175 | . 8 76 | 165 | . 9 79 | 172 | . - 데이터프레임을 바꿀 생각을 하는게 쉽지 않다. . (방법1) . df1[&#39;g&#39;]= &#39;f&#39; . df1 . w h g . 0 44 | 159 | f | . 1 48 | 160 | f | . 2 49 | 162 | f | . 3 58 | 165 | f | . 5 68 | 162 | f | . df2[&#39;g&#39;]= &#39;m&#39; . df2 . w h g . 4 62 | 167 | m | . 6 69 | 165 | m | . 7 70 | 175 | m | . 8 76 | 165 | m | . 9 79 | 172 | m | . pd.concat([df1,df2]) . w h g . 0 44 | 159 | f | . 1 48 | 160 | f | . 2 49 | 162 | f | . 3 58 | 165 | f | . 5 68 | 162 | f | . 4 62 | 167 | m | . 6 69 | 165 | m | . 7 70 | 175 | m | . 8 76 | 165 | m | . 9 79 | 172 | m | . (방법2) . df1=df.query(&quot;g ==&#39;f&#39;&quot;)[[&#39;w&#39;,&#39;h&#39;]] ## 여성.csv df2=df.query(&quot;g ==&#39;m&#39;&quot;)[[&#39;w&#39;,&#39;h&#39;]] ## 남성.csv . pd.concat([df1,df2],keys=[&#39;f&#39;,&#39;m&#39;]).reset_index().iloc[:,[0,2,3]].rename(columns={&#39;level_0&#39;:&#39;g&#39;}) . g w h . 0 f | 44 | 159 | . 1 f | 48 | 160 | . 2 f | 49 | 162 | . 3 f | 58 | 165 | . 4 f | 68 | 162 | . 5 m | 62 | 167 | . 6 m | 69 | 165 | . 7 m | 70 | 175 | . 8 m | 76 | 165 | . 9 m | 79 | 172 | . - 어려운점: . (1) 센스가 없어서 색깔을 넣어서 그룹을 구분할 생각을 못함 | (2) 변형해야할 데이터를 생각못함 | (3) 데이터를 변형할 생각을 한다고 해도 변형하는 실제적인 코드를 구현할 수 없음 (그래서 엑셀을 킨다..) (1) 기획력부족 -&gt; 훌륭한 시각화를 많이 볼것 | (2) 데이터프레임에 대한 이해도가 부족 -&gt; tidydata에 대한 개념 | (3) 프로그래밍 능력 부족 -&gt; 코딩공부열심히.. | . | . - 목표: . (2) 어떠한 데이터 형태로 변형해야하는가? | (3) 그러한 데이터 형태로 바꾸기 위한 pandas 숙련도 | .",
            "url": "https://cjfal.github.io/dj/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/10/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EA%B3%B5%EB%B6%80-%EC%95%84%EB%A7%885.html",
            "relUrl": "/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/10/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EA%B3%B5%EB%B6%80-%EC%95%84%EB%A7%885.html",
            "date": " • Oct 10, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "데이터시각화 10/6 강의 과제",
            "content": "import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns from scipy import stats . &#45936;&#51060;&#53552;&#49884;&#44033;&#54868; 10/6&#51068;&#51088; &#44284;&#51228; 201514142 &#44608;&#46041;&#51456; . np.random.seed(201514142) x=np.random.chisquare(df=5, size=100) . fig, ax =plt.subplots(1,3) (ax1,ax2,ax3) =ax . sns.boxplot(x,ax=ax1) #ax1에 박스플랏을 넣겠다 sns.histplot(x,kde=True,ax=ax2) #ax2에 히스토그램 _ = stats.probplot(x,plot=ax3) #ax3에 qq플랏 . fig.set_figwidth(10) fig.set_figheight(5) fig.tight_layout() fig .",
            "url": "https://cjfal.github.io/dj/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/08/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EA%B3%BC%EC%A0%9C.html",
            "relUrl": "/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/08/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EA%B3%BC%EC%A0%9C.html",
            "date": " • Oct 8, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "데이터시각화 중간고사 공부2",
            "content": "import matplotlib.pyplot as plt import numpy as np import cv2 as cv import pandas as pd . Histogram Equalization, HE, &#55176;&#49828;&#53664;&#44536;&#47016; &#54217;&#54876;&#54868; . 이미지의 명암대비 개선 . . 이미지 불러오기 . img = cv.imread(&#39;사진이름.확장자&#39;,흑백-&gt;0) . img = cv.imread(&#39;450px-Unequalized_Hawkes_Bay_NZ.jpg&#39;,0) . img 입력시 array 숫자들이 출력됨 . $ to$ 그림이 픽셀의 조합이기때문 . $ to$ 이미지자료는 사실 0~255 사이의 어떠한 숫자들이 포함된 매트릭스일 뿐 . $ to$ 매트릭스에 있는 숫자들을 색깔로 표현하여 값이 클수록 하얗게, 값이 작을수록 검게 그린다. 극단적으로 0은 검은색, 255는 흰색이다. . plt.imshow(img,cmap=&#39;gray&#39;,vmin=0,vmax=255) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x7fd5b2e211f0&gt; . - 이미지가 넘파이 매트릭스일 뿐이라는 것을 판다스를 활용하면 더 잘 시각화하여 이해할 수 있다. . plt.imshow(img[200:300,400:500],cmap=&#39;gray&#39;,vmin=0,vmax=255) . &lt;matplotlib.image.AxesImage at 0x7fd5b266f100&gt; . df=pd.DataFrame(img) df.iloc[200:300,400:500].style.set_properties(**{&#39;font-size&#39;:&#39;10pt&#39;}).background_gradient(&#39;gray&#39;,vmin=0,vmax=255) . 데이터 프레임인데 각 셀의 색이 다르다 -&gt; like 그림을 크게 확대한것 . img.flatten().shape . (135000,) . fig1=plt.hist(img.flatten(),256,[0,256]) . - 히스토그램을 그려보니 120~200 사이에 너무 값들이 모여있음 . - 원래 0~255까지의 색을 표현할 수 있는데 컴퓨터가 표현가능한 색상보다 적은 조합만을 사용하고 있음. . $ to$ 더 많은 색상 표현 가능 = 히스토그램을 더 평평하게 = 선명 . img2=cv.equalizeHist(img) . fig2_1=plt.hist(img2.flatten(),256,[0,256]) . fig2_2=plt.hist(img2.flatten(),10,[0,256]) . plt.imshow(img2,cmap=&#39;gray&#39;,vmin=0,vmax=255) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x7fd5b05eb0d0&gt; . _img=np.hstack((img,img2)) . plt.imshow(_img,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7fd5b051af40&gt; . $ to$ 수정된 사진 비교 (더 진해 졌다) . . &#51060;&#48120;&#51648; &#51088;&#47308;&#50640; &#45824;&#54620; &#51060;&#54644; . - 흑백이미지 . 차원: 세로픽셀수 $ times$ 가로픽셀수 | 값: 0~255 (값이 클수록 흰색) | . - 칼라이미지 . 차원: 세로픽셀수 $ times$ 가로픽셀수 $ times$ 3 | 값: 0~255 (값이 클수록 진한빨강, 진한파랑, 진한녹색) | . hani=cv.imread(&#39;450px-Unequalized_Hawkes_Bay_NZ.jpg&#39;) . import matplotlib.pyplot as plt plt.imshow(hani) . &lt;matplotlib.image.AxesImage at 0x7fd5b0938b50&gt; . hani.shape . (300, 450, 3) . import numpy as np hani_red=np.zeros_like(hani) hani_green=np.zeros_like(hani) hani_blue=np.zeros_like(hani) hani_red[:,:,0]=hani[:,:,0] hani_green[:,:,1]=hani[:,:,1] hani_blue[:,:,2]=hani[:,:,2] . _img2=np.hstack((hani_red,hani_green,hani_blue)) plt.imshow(_img2) . &lt;matplotlib.image.AxesImage at 0x7fd5b03e8580&gt; . plt.imshow(hani_red+hani_green+hani_blue) . &lt;matplotlib.image.AxesImage at 0x7fd5b033aac0&gt; . &#49328;&#51216;&#46020; (scatter plot) . 산점도:직교 좌표계(도표)를 이용해 좌표상의 점들을 표시함으로써 두 개 변수 간의 관계를 나타내는 그래프 방법이다. 산점도는 보통 $X$와 $Y$의 관계를 알고 싶을 경우 그린다. . 박스플랏, 히스토그램은 그림을 그리기 위해서 하나의 변수만 필요함; 산점도를 위해서는 두개의 변수가 필요함. | 두변수 $ to$ 두변수의 관계 | . &#47800;&#47924;&#44172;&#50752; &#53412; &#50696;&#49884; . x=[44,48,49,58,62,68,69,70,76,79] y=[159,160,162,165,167,162,165,175,165,172] . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5b027e4f0&gt;] . 키가 큰 사람일수록 몸무게도 많이 나간다. (반대도 성립) | 키와 몸무게는 관계가 있어보인다. (정비례) | . - 얼만큼 정비례인지? . 이 질문에 대답하기 위해서는 상관계수의 개념을 알아야 한다. | 상관계수에 대한 개념은 산점도를 이해함에 있어서 핵심개념이다. | . - (표본)상관계수 . $$r= frac{ sum_{i=1}^{n}(x_i- bar{x})(y_i- bar{y}) }{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2 sum_{i=1}^{n}(y_i- bar{y})^2 }} $$ . 분모를 계산했다고 치자. 계산한 값을 어떤 상수 $c$라고 생각하자. 이 값을 분자안에 넣을수도 있다. | . $$r= sum_{i=1}^{n} frac{1}{c}(x_i- bar{x})(y_i- bar{y}) $$ . 위의 식은 아래와 같이 다시 쓸 수 있다. | . $$r= sum_{i=1}^{n} left( frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2}} frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^{n}(y_i- bar{y})^2}} right)$$ . 편의상 아래와 같이 정의하자. | . $$ tilde{x}_i= frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^n(x_i- bar{x})^2}}$$ . $$ tilde{y}_i= frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^n(y_i- bar{y})^2}}$$ . 결국 $r$은 아래와 같은 모양이다. | . $$r= sum_{i=1}^{n} tilde{x}_i tilde{y}_i $$ . x=np.array(x) y=np.array(y) . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5b02662e0&gt;] . plt.plot(x-np.mean(x), y-np.mean(y),&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5b01c7190&gt;] . $$r= sum_{i=1}^{n} left( frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2}} frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^{n}(y_i- bar{y})^2}} right)$$ . a=np.sqrt(np.sum((x-np.mean(x))**2)) #괄호 왼쪽 분모 b=np.sqrt(np.sum((y-np.mean(y))**2)) #괄호 오른쪽 분모 a,b . (36.58004920718396, 15.218409903797438) . $a&gt;b$ 이므로 $ {x_i }$들이 $ {y_i }$들 보다 좀 더 퍼져있다. (=평균근처에 몰려있지 않다) | . - 사실 $a,b$는 아래와 같이 계산할 수 있다. . $a= sqrt{n} times{ tt np.std(x)}$ . $b= sqrt{n} times{ tt np.std(y)}$ . n=len(x) np.sqrt(n)*np.std(x), np.sqrt(n)*np.std(y) . (36.58004920718397, 15.21840990379744) . ${ tt np.std(x)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(x_i- bar{x})^2}$ | ${ tt np.std(y)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(y_i- bar{y})^2}$ | . . Note: ${ tt np.std(x,ddof=1)}= sqrt{ frac{1}{n-1} sum_{i=1}^{n}(x_i- bar{x})^2}$ . - 이제 $( tilde{x}_i, tilde{y}_i)$를 그려보자. . xx= (x-np.mean(x))/a yy= (y-np.mean(y))/b plt.plot(xx,yy,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5b01a9580&gt;] . 평균도 비슷하고 퍼진정도도 비슷하다. | . - 질문1: $r$의 값이 양수인가? 음수인가? . plotly 사용하여 그려보자. . import plotly.express as px from IPython.display import HTML fig=px.scatter(x=xx, y=yy) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . $ tilde{x}_i$, $ tilde{y}_i$ 를 곱한값이 양수인것과 음수인것을 체크해보자. | 양수인쪽이 많은지 음수인쪽이 많은지 생각해보자. | $r= sum_{i=1}^{n} tilde{x}_i tilde{y}_i$ 의 부호는? $ to$ 양수인 쪽이 훨씬 많다축=0 기준으로 사분면을 그어 양수쪽 기울기일지 그 수를 확인 . 1,3분면 :양수 . | . - 질문2: 아래와 같은 두개의 데이터set이 있다고 하자. . x1=np.arange(0,10,0.1) y1=x1+np.random.normal(loc=0,scale=1.0,size=len(x1)) . plt.plot(x1,y1,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5ab5801c0&gt;] . x2=np.arange(0,10,0.1) y2=x2+np.random.normal(loc=0,scale=7.0,size=len(x2)) plt.plot(x2,y2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5ab54cdf0&gt;] . 같이 그리기 . plt.plot(x1,y1,&#39;o&#39;) plt.plot(x2,y2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5ab523f40&gt;] . 각 데이터셋의 표준상관계수를 각각 $r_1$(파란색), $r_2$(주황색)라고 하자. . (1) $r_1$, $r_2$의 부호는 양수인가? 음수인가? . $r_1$ :양수&gt; $r_2$ :양수 . n=len(x1) xx1= (x1-np.mean(x1)) / (np.std(x1) * np.sqrt(n)) yy1= (y1-np.mean(y1)) / (np.std(y1) * np.sqrt(n)) xx2= (x2-np.mean(x2)) / (np.std(x2) * np.sqrt(n)) yy2= (y2-np.mean(y2)) / (np.std(y2) * np.sqrt(n)) . plt.plot(xx1,yy1,&#39;o&#39;) plt.plot(xx2,yy2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd5ab4885b0&gt;] . (2) $r_1,r_2$의 값중 어떠한 값이 더 절대값이 큰가? . &#49345;&#44288;&#44228;&#49688; &#44228;&#49328; . sum(xx1*yy1), sum(xx2*yy2) . (0.9361646680973845, 0.4067814338019102) . 상관계수 r1이 더 크다 (절댓값이 더 크다) .",
            "url": "https://cjfal.github.io/dj/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EA%B3%B5%EB%B6%802.html",
            "relUrl": "/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EA%B3%B5%EB%B6%802.html",
            "date": " • Oct 3, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "데이터시각화 중간고사 공부1",
            "content": "import matplotlib.pyplot as plt import numpy as np . boxplot . 단순한 평균비교보다 분포를 비교해보는 것이 중요하다. 분포를 살펴보는 방법 중 유용한 방법이 박스플랏이다. . 함수 :&gt;&gt;import matplotlib.pyplot as plt&gt;&gt;plt.boxplot() . y1=[75,75,76,76,77,77,79,79,79,98] # A선생님에게 통계학을 배운 학생의 점수들 y2=[76,76,77,77,78,78,80,80,80,81] # B선생님에게 통계학을 배운 학생의 점수들 . np.mean(y1), np.mean(y2) . (79.1, 78.3) . plt.boxplot(y1) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae2999040&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae29993a0&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae2999700&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2999a60&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae298ec70&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae2999dc0&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae29a5190&gt;], &#39;means&#39;: []} . plt.boxplot(y2) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae51dec10&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae51def70&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae51ea310&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae51ea670&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae51de8b0&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae51ea9d0&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae51ead30&gt;], &#39;means&#39;: []} . plt.boxplot([y1,y2]) # 나란히 그리기 . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae5149670&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae51499d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae5153e80&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae515f220&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae5149d30&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae51530d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae515f580&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae515f8e0&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae5149310&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae5153b20&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae5153430&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae515fc40&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae5153790&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae515ffa0&gt;], &#39;means&#39;: []} . 박스플랏 설명 그림 . np.random.seed(916170) # connection path is here: https://stackoverflow.com/questions/6146290/plotting-a-line-over-several-graphs mu, sigma = 0, 1 # mean and standard deviation s = np.random.normal(mu, sigma, 1000) fig, axes = plt.subplots(nrows = 1, ncols = 1, figsize=(10, 5)) # rectangular box plot bplot = axes.boxplot(s, vert=False, patch_artist=True, showfliers=True, # This would show outliers (the remaining .7% of the data) positions = [0], boxprops = dict(linestyle=&#39;--&#39;, linewidth=2, color=&#39;Black&#39;, facecolor = &#39;red&#39;, alpha = .4), medianprops = dict(linestyle=&#39;-&#39;, linewidth=2, color=&#39;Yellow&#39;), whiskerprops = dict(linestyle=&#39;-&#39;, linewidth=2, color=&#39;Blue&#39;, alpha = .4), capprops = dict(linestyle=&#39;-&#39;, linewidth=2, color=&#39;Black&#39;), flierprops = dict(marker=&#39;o&#39;, markerfacecolor=&#39;green&#39;, markersize=10, linestyle=&#39;none&#39;, alpha = .4), widths = .3, zorder = 1) axes.set_xlim(-4, 4) plt.xticks(fontsize = 14) axes.set_yticks([]) axes.annotate(r&#39;&#39;, xy=(-.73, .205), xycoords=&#39;data&#39;, xytext=(.66, .205), textcoords=&#39;data&#39;, arrowprops=dict(arrowstyle=&quot;|-|&quot;, connectionstyle=&quot;arc3&quot;) ); axes.text(0, .25, &quot;Interquartile Range n(IQR)&quot;, horizontalalignment=&#39;center&#39;, fontsize=18) axes.text(0, -.21, r&quot;Median&quot;, horizontalalignment=&#39;center&#39;, fontsize=16); axes.text(2.65, -.15, &quot; &quot;Maximum &quot;&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(-2.65, -.15, &quot; &quot;Minimum &quot;&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(-.68, -.24, r&quot;Q1&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(-2.65, -.21, r&quot;(Q1 - 1.5*IQR)&quot;, horizontalalignment=&#39;center&#39;, fontsize=16); axes.text(.6745, -.24, r&quot;Q3&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(.6745, -.30, r&quot;(75th Percentile)&quot;, horizontalalignment=&#39;center&#39;, fontsize=12); axes.text(-.68, -.30, r&quot;(25th Percentile)&quot;, horizontalalignment=&#39;center&#39;, fontsize=12); axes.text(2.65, -.21, r&quot;(Q3 + 1.5*IQR)&quot;, horizontalalignment=&#39;center&#39;, fontsize=16); axes.annotate(&#39;Outliers&#39;, xy=(2.93,0.015), xytext=(2.52,0.20), fontsize = 18, arrowprops={&#39;arrowstyle&#39;: &#39;-&gt;&#39;, &#39;color&#39;: &#39;black&#39;, &#39;lw&#39;: 2}, va=&#39;center&#39;); axes.annotate(&#39;Outliers&#39;, xy=(-3.01,0.015), xytext=(-3.41,0.20), fontsize = 18, arrowprops={&#39;arrowstyle&#39;: &#39;-&gt;&#39;, &#39;color&#39;: &#39;black&#39;, &#39;lw&#39;: 2}, va=&#39;center&#39;); fig.tight_layout() . . plotly . 그림(그래프)에 마우스를 올리면 상호작용하는 그림 . plotly.express 와 pandas 필요 . import plotly.express as px import pandas as pd from IPython.display import HTML . 박스플랏에서 구한 성적을 df로 구현. . 열에 A라는것을 y1 수(길이)만큼 배열 . pd.concat([df1,df2]) :데이터프레임 합치기 ignore_index=True -&gt; 기존에 있던 인덱스를 무시해라 . 0~9 / 0~9 (기존) -&gt; 0~19 (무시) . A=pd.DataFrame({&#39;score&#39;:y1,&#39;class&#39;:[&#39;A&#39;]*len(y1)}) B=pd.DataFrame({&#39;score&#39;:y2,&#39;class&#39;:[&#39;B&#39;]*len(y2)}) . df=pd.concat([A,B],ignore_index=True) . html 같은 경우 블로그에 올릴 때 유용하다. (포맷을 변환) . 반응형 플랏을 볼 수 있다. (마우스 올리면 값나옴,HTML형태로 그려진 그림) . fig=px.box(data_frame=df, x=&#39;class&#39;,y=&#39;score&#39;) . HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . Histogram . X축이 변수의 구간, Y축은 그 구간에 포함된 빈도를 의미하는 그림 . plt.hist() 함수 이용 . np.random.normal() :정규분포&gt; &gt; loc:평균 , scale:표준편차 , size:표본수 . plt.hist(np.random.normal(loc=0, scale=1, size=1000000)) . (array([2.40000e+01, 1.21000e+03, 2.13380e+04, 1.39948e+05, 3.51614e+05, 3.39662e+05, 1.27147e+05, 1.80510e+04, 9.87000e+02, 1.90000e+01]), array([-5.05590169, -4.03792348, -3.01994528, -2.00196708, -0.98398887, 0.03398933, 1.05196753, 2.06994573, 3.08792394, 4.10590214, 5.12388034]), &lt;BarContainer object of 10 artists&gt;) . bins를 이용해 더 촘촘하게 그릴 수 있다. (정규분포에 더 가까워짐) . plt.hist(np.random.normal(loc=0, scale=1, size=1000000),bins=50) . (array([2.0000e+00, 6.0000e+00, 1.6000e+01, 3.9000e+01, 6.1000e+01, 1.3800e+02, 2.9000e+02, 5.0700e+02, 9.0400e+02, 1.6030e+03, 2.6310e+03, 4.1220e+03, 6.4460e+03, 9.5500e+03, 1.3819e+04, 1.9254e+04, 2.5638e+04, 3.3537e+04, 4.1336e+04, 4.9881e+04, 5.8100e+04, 6.5370e+04, 7.0605e+04, 7.3583e+04, 7.4674e+04, 7.2582e+04, 6.8887e+04, 6.2318e+04, 5.4823e+04, 4.6453e+04, 3.8169e+04, 3.0141e+04, 2.3006e+04, 1.7010e+04, 1.2102e+04, 8.3090e+03, 5.5450e+03, 3.4440e+03, 2.2440e+03, 1.2700e+03, 7.4300e+02, 4.3200e+02, 2.1800e+02, 9.4000e+01, 5.4000e+01, 1.9000e+01, 1.3000e+01, 5.0000e+00, 4.0000e+00, 3.0000e+00]), array([-4.56309489, -4.37544858, -4.18780228, -4.00015598, -3.81250967, -3.62486337, -3.43721707, -3.24957076, -3.06192446, -2.87427816, -2.68663185, -2.49898555, -2.31133925, -2.12369294, -1.93604664, -1.74840034, -1.56075403, -1.37310773, -1.18546143, -0.99781512, -0.81016882, -0.62252252, -0.43487621, -0.24722991, -0.05958361, 0.1280627 , 0.315709 , 0.5033553 , 0.69100161, 0.87864791, 1.06629421, 1.25394051, 1.44158682, 1.62923312, 1.81687942, 2.00452573, 2.19217203, 2.37981833, 2.56746464, 2.75511094, 2.94275724, 3.13040355, 3.31804985, 3.50569615, 3.69334246, 3.88098876, 4.06863506, 4.25628137, 4.44392767, 4.63157397, 4.81922028]), &lt;BarContainer object of 50 artists&gt;) . . 평균이 항상 좋은 중심경향값은 아니지만, 특수한 상황을 가정하면 평균이 좋은 중심경향값임 . np.random.seed(43052) #값이 안변하도록 시드설정 y1=np.random.normal(loc=0,scale=1,size=10000) #전북고 A반의 통계학 성적이라 생각하자. y2=np.random.normal(loc=0.5,scale=1,size=10000) #전북고 B반의 통계학 성적이라 생각하자. . np.mean(y1), np.mean(y2) #np.mean:평균, 튜플로 나옴 . (-0.011790879905079434, 0.4979147460611458) . (np.mean(y2)-np.mean(y1)).round(3) #소수 n째자리에서 반올림 . 0.51 . plt.boxplot([y1,y2]) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae27ac7c0&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae27acb20&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2737fa0&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2743340&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae27ace80&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2737220&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae27436a0&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2743a00&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae27ac460&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2737c40&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae2737580&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2743d60&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f3ae27378e0&gt;, &lt;matplotlib.lines.Line2D at 0x7f3ae2751100&gt;], &#39;means&#39;: []} . 분포의 모양이 거의 일치하다고 할만큼 비슷하다. . $B반의 성적 approx A반의 성적 + 0.51$ 라고 주장해도 큰 무리가 없음 . 정규분포인지는 어떻게 알까? $ to$ 히스토그램 그려보기 . plt.hist(y1,bins=50) . plt.hist(y2,bins=50) . plt.hist([y1,y2],bins=200) #같이 그리기 . $ to$ 아웃풋이 너무 지저분하다. . &#49352;&#47196;&#50868; &#54056;&#53412;&#51648; &#51060;&#50857; . R:ggplot2 가 대세&gt; Python:&gt;&gt;matplotlib (매트랩 모방) . seaborn . plotnine (ggplot모방) . plotly 등등 많음 . seaborn . 깔끔하게 히스토그램을 그리는 패키지 . df를 입력으로 받는다 . import seaborn as sns . A=pd.DataFrame({&#39;score&#39;:y1,&#39;class&#39;:[&#39;A&#39;]*len(y1)}) B=pd.DataFrame({&#39;score&#39;:y2,&#39;class&#39;:[&#39;B&#39;]*len(y2)}) df=pd.concat([A,B],ignore_index=True) . sns.histplot(df,x=&#39;score&#39;,hue=&#39;class&#39;) . &lt;AxesSubplot:xlabel=&#39;score&#39;, ylabel=&#39;Count&#39;&gt; . plotnine . 인터랙티브 그래프를 위해서 plotly 홈페이지를 방문하여 적당한 코드를 가져온다. . from plotnine import * . ggplot(df)+geom_histogram(aes(x=&#39;score&#39;,color=&#39;class&#39;)) . /home/kdj/anaconda3/lib/python3.8/site-packages/plotnine/stats/stat_bin.py:95: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 84&#39;. Pick better value with &#39;binwidth&#39;. . &lt;ggplot: (8743170859795)&gt; . $ to$ 별로 알아보기가 힘들다 . color를fill로 바꿔줌 , position을 동등하게 , alpha: 투명도 . ggplot(df)+geom_histogram(aes(x=&#39;score&#39;,fill=&#39;class&#39;),position=&#39;identity&#39;,alpha=0.5) . /home/kdj/anaconda3/lib/python3.8/site-packages/plotnine/stats/stat_bin.py:95: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 84&#39;. Pick better value with &#39;binwidth&#39;. . &lt;ggplot: (8743171077340)&gt; . plotly &#54876;&#50857; . 구글에 검색하면 예시가 잘 나와있다. . import plotly.figure_factory as ff import numpy as np hist_data=[y1,y2] group_labels=[&#39;A&#39;,&#39;B&#39;] fig = ff.create_distplot(hist_data, group_labels, bin_size=.2, show_rug=False) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . .",
            "url": "https://cjfal.github.io/dj/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/02/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%941.html",
            "relUrl": "/python/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94/2021/10/02/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%941.html",
            "date": " • Oct 2, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "4주차 회귀분석 연습문제 4.8 R 풀이",
            "content": "base . A &lt;- c(5,6,7,8,9,10,11,12,13,14) B &lt;- c(89,87,98,110,103,114,116,110,126,130) . 1)2) &#51208;&#54200;&#44284; &#44592;&#50872;&#44592;&#51032; &#49888;&#47280;&#44396;&#44036; &#48143; &#44160;&#51221; . lm48 &lt;- lm(B~A) summary(lm48) . Call: lm(formula = B ~ A) Residuals: Min 1Q Median 3Q Max -9.3758 -2.1545 0.9152 2.0864 8.3455 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 66.212 5.767 11.482 3.00e-06 *** A 4.430 0.581 7.625 6.16e-05 *** Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 5.278 on 8 degrees of freedom Multiple R-squared: 0.879, Adjusted R-squared: 0.8639 F-statistic: 58.14 on 1 and 8 DF, p-value: 6.161e-05 . coeffs &lt;- coefficients(lm48) confint(lm48,level = 0.95) # 기울기와 절편의 95% 신뢰구간 . A matrix: 2 × 2 of type dbl 2.5 %97.5 % . (Intercept)52.914087 | 79.510156 | . A 3.090412 | 5.770194 | . R을 통해 y=β_0+β_1 x+ϵ 를 가정해 본 결과 절편β_0은 66.212, 기울기β_1은 4.430이 나왔다. 절편의 신뢰구간을 추정해본 결과 절편 β_0의 신뢰구간은 (52.914087, 79.510156) 으로 나왔다. 이어서 자유도가 8인 t분포에서 가운데 면적이 95% 인 경우의 t*값은 2.306이다. 그런데 summary 에서 확인할 수 있는 절편의 t-value은 11.482로 2.306보다 크다. 즉 영가설을 기각한다. . 기울기의 신뢰구간은 (3.090412, 5.770194)이다. summary에서 절편에 대한 t-value 값은 7.625인데 이 값은 자유도 8인 t분포에서 가운데 면적이 95%일때의 t*값인 2.306 보다 크므로 영가설을 기각한다. . 3) &#48516;&#49328;&#48516;&#49437;&#54364;&#47196; &#44592;&#50872;&#44592; &#44160;&#51221; . anova(lm48) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . A1 | 1619.2758 | 1619.27576 | 58.13643 | 6.160731e-05 | . Residuals8 | 222.8242 | 27.85303 | NA | NA | . F-value는 58.136 이다. 분자의 자유도 1 과 분모의 자유도가 8인 F-분포에서 p-value 는 6.161^(-10)이다. 이 p값은 굉장히 작기 때문에 선형모형(기울기와 편차)의 가정이 좋은 가정이라고 말할 수 있다. . 4) &#44208;&#51221;&#44228;&#49688;&#50752; &#51032;&#48120; . (cor(A,B))^2 . 0.879037922792333 결정계수 R^2는 0.8790379이다. 1에 가까운 값으로 추정된 방정식이 판매액과 광고비를 잘 나타내 준다고 말할 수 있다 . 5) x=10 &#51068;&#46412; yhat &#49888;&#47280;&#44396;&#44036; . q10 &lt;- data.frame(A=10) predict(lm48,q10,level=0.95,interval=&quot;confidence&quot;) . A matrix: 1 × 3 of type dbl fitlwrupr . 1110.5152 | 106.6087 | 114.4216 | . 적합된 광고비 값은 110.5152이고, 그 신뢰구간은 (106.6087,114.4216) 이다. . 6) x=10 &#51068;&#46412; y &#50696;&#52769;&#44396;&#44036; . predict(lm48,q10,level=0.95,interval=&quot;predict&quot;) . A matrix: 1 × 3 of type dbl fitlwrupr . 1110.5152 | 97.73341 | 123.2969 | . 적합된 광고비 값은 110.5152이고, 그 예측구간은 (97.73341,123.2969) 이다. . q8 &lt;- data.frame(A=8) q9 &lt;- data.frame(A=9) q10 &lt;- data.frame(A=10) q11 &lt;- data.frame(A=11) q12 &lt;- data.frame(A=12) predict(lm48,q8,level=0.95,interval=&quot;confidence&quot;) predict(lm48,q9,level=0.95,interval=&quot;confidence&quot;) predict(lm48,q10,level=0.95,interval=&quot;confidence&quot;) predict(lm48,q11,level=0.95,interval=&quot;confidence&quot;) predict(lm48,q12,level=0.95,interval=&quot;confidence&quot;) predict(lm48,q8,level=0.95,interval=&quot;predict&quot;) predict(lm48,q9,level=0.95,interval=&quot;predict&quot;) predict(lm48,q10,level=0.95,interval=&quot;predict&quot;) predict(lm48,q11,level=0.95,interval=&quot;predict&quot;) predict(lm48,q12,level=0.95,interval=&quot;predict&quot;) . A matrix: 1 × 3 of type dbl fitlwrupr . 1101.6545 | 97.3128 | 105.9963 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1106.0848 | 102.1784 | 109.9913 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1110.5152 | 106.6087 | 114.4216 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1114.9455 | 110.6037 | 119.2872 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1119.3758 | 114.2736 | 124.4779 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1101.6545 | 88.73311 | 114.576 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1106.0848 | 93.30311 | 118.8666 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1110.5152 | 97.73341 | 123.2969 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1114.9455 | 102.024 | 127.8669 | . A matrix: 1 × 3 of type dbl fitlwrupr . 1119.3758 | 106.1794 | 132.5721 | . &#49888;&#47280;&#45824; &#50696;&#52769;&#45824; &#46020;&#49884; . m_conf &lt;- predict(lm48,level=0.95,interval=&quot;confidence&quot;) plot(B~A) lwr &lt;- m_conf[,2] upr &lt;- m_conf[,3] sx &lt;- sort(A, index.return=TRUE) abline(coef(lm48),lwd=2) lines(sx$x, lwr[sx$ix], col=&quot;blue&quot;, lty=2) lines(sx$x, upr[sx$ix], col=&quot;blue&quot;, lty=2) m_pred &lt;- predict(lm48,level=0.95,interval=&quot;predict&quot;) p_lwr &lt;- m_pred[,2] p_upr &lt;- m_pred[,3] lines(A, p_lwr, col=&quot;red&quot;, lty=2) lines(A, p_upr, col=&quot;red&quot;, lty=2) . Warning message in predict.lm(lm48, level = 0.95, interval = &#34;predict&#34;): “predictions on current data refer to _future_ responses ” . (오류는 무슨뜻일까.. 문제는 없어보인다) . 붉은선은 예측대, 파란선은 신뢰대이다. 예측대가 신뢰대보다 더 넓은 범위를 차지하며 . 신뢰대와 예측대 모두 거의 중앙에 회귀선을 품고있는 모습을 하고 있다. . 값에따른 신뢰구간과 예측구간 . x_0 신뢰구간(confidence) 예측구간(predict) . | lwr | upr | lwr | Upr | . 8 | 97.31280 | 105.9963 | 88.73311 | 114.5760 | . 9 | 102.1784 | 109.9913 | 93.30311 | 118.8666 | . 10 | 106.6087 | 114.4216 | 97.73341 | 123.2969 | . 11 | 110.6037 | 119.2872 | 102.0240 | 127.8669 | . 12 | 114.2736 | 124.4779 | 106.1794 | 132.5721 | .",
            "url": "https://cjfal.github.io/dj/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/09/30/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_4_8.html",
            "relUrl": "/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/09/30/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_4_8.html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "4주차 회귀분석 연습문제 4.1 R 풀이",
            "content": "Base 코드 . x &lt;- c(28.0,28.0,32.5,39.0,45.9,57.8,58.1,62.5) #시간당평균온도 y &lt;- c(12.4,11.7,12.4,10.8,9.4,9.5,8.0,7.5) #석탄소비량 lm31 &lt;- lm(y~x) . 1) &#44592;&#50872;&#44592;&#50752; &#51208;&#54200;&#51032; &#49888;&#47280;&#44396;&#44036; &#44396;&#54616;&#44592; . summary(lm31) . Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -0.5663 -0.4432 -0.1958 0.2879 1.0560 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 15.83786 0.80177 19.754 1.09e-06 *** x -0.12792 0.01746 -7.328 0.00033 *** Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 0.6542 on 6 degrees of freedom Multiple R-squared: 0.8995, Adjusted R-squared: 0.8827 F-statistic: 53.69 on 1 and 6 DF, p-value: 0.0003301 . coeffs &lt;- coefficients(lm31) confint(lm31,coeffs[2],level=0.95) #기울기 b1 의 95% 신뢰구간 . A matrix: 1 × 2 of type dbl 2.5 %97.5 % . x-0.1706383 | -0.08520517 | . confint(lm31,level = 0.95) #절편 b0 의 95% 신뢰구간 . A matrix: 2 × 2 of type dbl 2.5 %97.5 % . (Intercept)13.8759886 | 17.79972621 | . x-0.1706383 | -0.08520517 | . 2) &#49888;&#47280;&#44396;&#44036;&#51032; &#51032;&#48120; . 시간당 평균온도를 한 단위(℉) 늘리면 석탄소비량(ton)은 -0.171과 -0.0852 사이의 어느 한 값의 배수만큼 평균적으로 증가함을 신뢰계수 0.95로 예측할 수 있다. . 3) &#44032;&#49444; &#44160;&#51221; &#50689;&#44032;&#49444;=0 &#50976;&#51032;&#49688;&#51456; 0.05 . summary(lm31) . Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -0.5663 -0.4432 -0.1958 0.2879 1.0560 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 15.83786 0.80177 19.754 1.09e-06 *** x -0.12792 0.01746 -7.328 0.00033 *** Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 0.6542 on 6 degrees of freedom Multiple R-squared: 0.8995, Adjusted R-squared: 0.8827 F-statistic: 53.69 on 1 and 6 DF, p-value: 0.0003301 . 15.838 + 2.447* 0.01746 15.838 - 2.447* 0.01746 . 15.88072462 15.79527538 기울기의 추정값 b1 = 15.838 이고 표준오차 SE는 0.01746 이다. 자유도(degrees of freedom)=6 인 t분포에서 가운데 면적이 95%인 t*=2.447 이며 95% 신뢰구간은 다음과 같이 계산한다. b_1±t^*×SE=15.838 ±2.447 ×0.01746 . 95% 신뢰구간 : (15.79528 , 15.88072) . 이 결과로부터 기울기(평균온도가 1℉ 오를 때 석탄소비량 상승은 15.79528 ton 에서 15.88072 ton 사이에 있을 것이라고 95% 확신한다. . 4) &#44032;&#49444;&#44160;&#51221;2 . Pr(&gt;|t|) 값(p-value)의 값이 극히 작으므로 상당히 믿을 만한 정보이고, 영가설 H0를 기각한다. 즉, 기울기 β_1 은 의미있는 가정값이다. . 5) &#48516;&#49328;&#48516;&#49437;&#51012; &#53685;&#54620; &#44032;&#49444;&#44160;&#51221; . anova(lm31) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . x1 | 22.980816 | 22.980816 | 53.69488 | 0.0003300523 | . Residuals6 | 2.567934 | 0.427989 | NA | NA | . F-value는 53.695 이다. 분자의 자유도 1 과 6인 F-분포에서 p-value 는 0.00033301이다. 이 p값은 굉장히 작기 때문에 선형모형(기울기와 편차)의 가정이 좋은 가정이라고 말할 수 있다. . 6)&#49884;&#44036;&#45817; &#54217;&#44512; &#50728;&#46020;&#50640; &#46384;&#47480; &#49548;&#48708;&#47049; &#52628;&#51221;, &#49888;&#47280;&#44396;&#44036; &#44396;&#54616;&#44592; . q6 &lt;- data.frame(x=40) predict(lm31,q6, level=0.95,interval=&quot;confidence&quot;) #신뢰구간 . A matrix: 1 × 3 of type dbl fitlwrupr . 110.72099 | 10.1301 | 11.31188 | . 추정된 석탄소비량은 10.72099 ton 이다. 그 신뢰구간은 (10.1301, 11.31188) 이고 y값이 이 범위에 있을 확률이 95%라는 의미이다. . 7) &#50696;&#52769;&#44396;&#44036; &#52628;&#51221; . predict(lm31,q6, level=0.95,interval=&quot;predict&quot;)예측구간 . A matrix: 1 × 3 of type dbl fitlwrupr . 110.72099 | 9.014624 | 12.42735 | . 추정된 석탄소비량은 10.72099 ton 이다. 그 예측구간은 (9.014624, 12.42735) 이고 y값이 이 범위에 있을 확률이 95%라는 의미이다. . 8) 6&#48264; 7&#48264;&#47928;&#51228; &#48708;&#44368; . 신뢰구간:y의 평균이 존재하는 구간을 추정  모집단을 예측 변수의 특정 값의 반응변수의 값으로 제한한다. 예측구간:하나의 y가 존재하는 구간을 추정  모집단을 대부분 포함해야 하므로 구간이 더 넓다. . 9) &#44208;&#51221;&#44228;&#49688; &#48143; &#51032;&#48120; . cor(x,y) # 상관계수 . -0.948413871025354 상관 계수 r :-0.9484139  -1에 가까우므로 강한 음의 상관관계를 가진다고 볼 수 있다. . (cor(x,y))^2 #결정계수 . 0.899488870753297 결정 계수 R^2: 0.8994889 . 결정 계수는 온도변화로 석탄소비량의 89.95%를 설명한다는 뜻이다. . 결정 계수가 1에 거의 근접하므로 가정된 방정식이 온도변화와 석탄소비량의 관계를 잘 설명한다고 볼 수 있다. .",
            "url": "https://cjfal.github.io/dj/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/09/30/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_4_1.html",
            "relUrl": "/r/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D/2021/09/30/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_4_1.html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://cjfal.github.io/dj/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://cjfal.github.io/dj/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "김동준 소개 .",
          "url": "https://cjfal.github.io/dj/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://cjfal.github.io/dj/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}